generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums using PostgreSQL conventions
enum user_role {
  admin
  user
  api_user

  @@map("user_role")
}

enum api_key_status {
  active
  revoked
  expired
  rotated

  @@map("api_key_status")
}

enum function_runtime {
  javascript
  python
  typescript

  @@map("function_runtime")
}

enum execution_status {
  pending
  running
  completed
  failed
  timeout

  @@map("execution_status")
}

// Users table - core authentication and user management
model User {
  id                String    @id @default(uuid()) @db.Uuid
  email             String    @unique @db.VarChar(255)
  username          String?   @unique @db.VarChar(100)
  password_hash     String?   @db.VarChar(255)
  first_name        String?   @db.VarChar(100)
  last_name         String?   @db.VarChar(100)
  role              user_role @default(user)
  is_active         Boolean   @default(true)
  email_verified    Boolean   @default(false)
  email_verified_at DateTime?
  last_login_at     DateTime?
  
  // Account lockout fields
  failed_login_attempts Int      @default(0)
  account_locked_until  DateTime?
  last_failed_login     DateTime?
  password_changed_at   DateTime?
  password_history      Json?    @db.JsonB // Array of previous password hashes
  
  // MFA fields
  mfa_enabled       Boolean  @default(false)
  mfa_secret        String?  @db.VarChar(255)
  mfa_backup_codes  Json?    @db.JsonB // Array of encrypted backup codes
  mfa_verified_at   DateTime?
  
  // Session management
  active_sessions   Json?    @db.JsonB // Array of active session info
  device_tokens     Json?    @db.JsonB // Array of trusted device tokens
  
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  // Relations
  refresh_tokens   RefreshToken[]
  api_keys         ApiKey[]
  entities         Entity[]
  entity_records   EntityRecord[]
  functions        Function[]
  function_executions FunctionExecution[]
  audit_logs       AuditLog[]
  rate_limit_rules RateLimitRule[]
  oauth_accounts   OAuthAccount[]
  created_rate_limits RateLimitConfig[] @relation("rate_limit_creator")
  updated_rate_limits RateLimitConfig[] @relation("rate_limit_updater")
  created_settings    SystemSetting[]   @relation("setting_creator")
  updated_settings    SystemSetting[]   @relation("setting_updater")

  @@map("users")
  @@index([email])
  @@index([username])
  @@index([role])
  @@index([is_active])
  @@index([created_at])
}

// OAuth integration for third-party authentication
model OAuthAccount {
  id               String   @id @default(uuid()) @db.Uuid
  user_id          String   @db.Uuid
  provider         String   @db.VarChar(50)
  provider_user_id String   @db.VarChar(255)
  provider_email   String?  @db.VarChar(255)
  provider_name    String?  @db.VarChar(255)
  provider_avatar  String?  @db.VarChar(500)
  access_token     String?  @db.Text
  refresh_token    String?  @db.Text
  expires_at       DateTime?
  scope            String?  @db.VarChar(500)
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("oauth_accounts")
  @@unique([provider, provider_user_id], name: "provider_provider_user_id")
  @@index([user_id])
  @@index([provider])
}

// JWT refresh tokens
model RefreshToken {
  id         String   @id @default(uuid()) @db.Uuid
  token_hash String   @unique @db.VarChar(255)
  user_id    String   @db.Uuid
  expires_at DateTime
  created_at DateTime @default(now())

  // Relations
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
  @@index([user_id])
  @@index([expires_at])
}

// API Keys for programmatic access
model ApiKey {
  id           String         @id @default(uuid()) @db.Uuid
  name         String         @db.VarChar(255)
  key_hash     String         @unique @db.VarChar(255)
  key_prefix   String         @db.VarChar(20) // For easy identification
  user_id      String         @db.Uuid
  status       api_key_status @default(active)
  permissions  Json           @default("[]") @db.JsonB
  rate_limit   Int?           // requests per minute
  expires_at   DateTime?
  last_used_at DateTime?
  rotated_at   DateTime?
  rotated_to   String?        @db.Uuid // Reference to the new key after rotation
  created_at   DateTime       @default(now())
  updated_at   DateTime       @updatedAt

  // Relations
  user        User        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  usage_logs  ApiUsage[]

  @@map("api_keys")
  @@index([user_id])
  @@index([key_hash])
  @@index([status])
  @@index([expires_at])
  @@index([key_prefix])
}

// Entities - JSON Schema based data structures
model Entity {
  id           String   @id @default(uuid()) @db.Uuid
  name         String   @unique @db.VarChar(100) // URL-safe name
  display_name String   @db.VarChar(255)
  description  String?  @db.Text
  schema       Json     @db.JsonB
  version      Int      @default(1)
  is_active    Boolean  @default(true)
  created_by   String   @db.Uuid
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  // Relations
  creator        User           @relation(fields: [created_by], references: [id])
  entity_records EntityRecord[]
  api_endpoints  ApiEndpoint[]

  @@map("entities")
  @@index([name])
  @@index([created_by])
  @@index([is_active])
  @@index([created_at])
}

// Entity Records - actual data instances
model EntityRecord {
  id         String   @id @default(uuid()) @db.Uuid
  entity_id  String   @db.Uuid
  data       Json     @db.JsonB
  metadata   Json?    @db.JsonB
  created_by String   @db.Uuid
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relations
  entity  Entity @relation(fields: [entity_id], references: [id], onDelete: Cascade)
  creator User   @relation(fields: [created_by], references: [id])

  @@map("entity_records")
  @@index([entity_id])
  @@index([created_by])
  @@index([created_at])
  // GIN index for JSON data queries
  @@index([data], type: Gin)
}

// Functions - serverless function definitions
model Function {
  id          String           @id @default(uuid()) @db.Uuid
  name        String           @unique @db.VarChar(100)
  description String?          @db.Text
  code        String           @db.Text
  runtime     function_runtime @default(javascript)
  timeout     Int              @default(30) // seconds
  memory      Int              @default(128) // MB
  env_vars    Json?            @db.JsonB
  is_active   Boolean          @default(true)
  created_by  String           @db.Uuid
  created_at  DateTime         @default(now())
  updated_at  DateTime         @updatedAt

  // Relations
  creator    User                @relation(fields: [created_by], references: [id])
  executions FunctionExecution[]

  @@map("functions")
  @@index([name])
  @@index([created_by])
  @@index([runtime])
  @@index([is_active])
}

// Function execution logs
model FunctionExecution {
  id          String           @id @default(uuid()) @db.Uuid
  function_id String           @db.Uuid
  input       Json?            @db.JsonB
  output      Json?            @db.JsonB
  status      execution_status @default(pending)
  duration_ms Int?
  memory_used Int? // MB
  error       String?          @db.Text
  executed_by String?          @db.Uuid
  started_at  DateTime         @default(now())
  completed_at DateTime?

  // Relations
  function Function @relation(fields: [function_id], references: [id], onDelete: Cascade)
  executor User?    @relation(fields: [executed_by], references: [id], onDelete: SetNull)

  @@map("function_executions")
  @@index([function_id])
  @@index([status])
  @@index([started_at])
  @@index([executed_by])
}

// Dynamic API endpoints
model ApiEndpoint {
  id          String   @id @default(uuid()) @db.Uuid
  entity_id   String   @db.Uuid
  method      String   @db.VarChar(10) // GET, POST, PUT, DELETE, etc.
  path        String   @db.VarChar(500)
  description String?  @db.Text
  is_active   Boolean  @default(true)
  rate_limit  Int?     // requests per minute
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  entity Entity @relation(fields: [entity_id], references: [id], onDelete: Cascade)

  @@map("api_endpoints")
  @@unique([method, path])
  @@index([entity_id])
  @@index([method])
  @@index([is_active])
}

// Rate limiting rules
model RateLimitRule {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @db.VarChar(255)
  description String?  @db.Text
  pattern     String   @db.VarChar(500) // URL pattern or endpoint
  user_id     String?  @db.Uuid // null means global rule
  api_key_id  String?  @db.Uuid
  limit       Int      // requests per window
  window_ms   Int      // window in milliseconds
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  user User? @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("rate_limit_rules")
  @@index([user_id])
  @@index([pattern])
  @@index([is_active])
}

// Idempotency keys for safe request retries
model IdempotencyKey {
  id         String   @id @default(uuid()) @db.Uuid
  key        String   @unique @db.VarChar(255)
  request    Json     @db.JsonB
  response   Json?    @db.JsonB
  status     String   @db.VarChar(50)
  user_id    String?  @db.Uuid
  created_at DateTime @default(now())
  expires_at DateTime

  @@map("idempotency_keys")
  @@index([key])
  @@index([expires_at])
  @@index([user_id])
}

// Audit logging for compliance and debugging
model AuditLog {
  id          String   @id @default(uuid()) @db.Uuid
  user_id     String?  @db.Uuid
  action      String   @db.VarChar(100)
  entity_type String   @db.VarChar(100)
  entity_id   String?  @db.VarChar(255)
  details     Json?    @db.JsonB
  ip_address  String?  @db.VarChar(45) // IPv6 compatible
  user_agent  String?  @db.VarChar(1000)
  created_at  DateTime @default(now())

  // Relations
  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@map("audit_logs")
  @@index([user_id])
  @@index([action])
  @@index([entity_type])
  @@index([created_at])
  @@index([entity_id])
}

// System configuration settings
model SystemSetting {
  id          String   @id @default(uuid()) @db.Uuid
  key         String   @unique @db.VarChar(255)
  value       Json     @db.JsonB
  category    String   @db.VarChar(100) // 'security', 'general', 'api', etc.
  type        String   @db.VarChar(50)  // 'string', 'number', 'boolean', 'array', 'object'
  description String?  @db.Text
  is_active   Boolean  @default(true)
  is_public   Boolean  @default(false) // Can be read by non-admin users
  created_by  String?  @db.Uuid
  updated_by  String?  @db.Uuid
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  creator User? @relation("setting_creator", fields: [created_by], references: [id], onDelete: SetNull)
  updater User? @relation("setting_updater", fields: [updated_by], references: [id], onDelete: SetNull)

  @@map("system_settings")
  @@index([key])
  @@index([category])
  @@index([is_active])
  @@index([is_public])
}

// API usage analytics
model ApiUsage {
  id            String   @id @default(uuid()) @db.Uuid
  user_id       String?  @db.Uuid
  api_key_id    String?  @db.Uuid
  endpoint      String   @db.VarChar(500)
  method        String   @db.VarChar(10)
  status_code   Int
  response_time Int      // milliseconds
  request_size  Int?     // bytes
  response_size Int?     // bytes
  ip_address    String?  @db.VarChar(45)
  created_at    DateTime @default(now())

  // Relations
  api_key ApiKey? @relation(fields: [api_key_id], references: [id], onDelete: SetNull)

  @@map("api_usage")
  @@index([user_id])
  @@index([api_key_id])
  @@index([endpoint])
  @@index([created_at])
  @@index([status_code])
}

// Rate limit configuration
model RateLimitConfig {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique @db.VarChar(100) // e.g., 'default', 'auth', 'api'
  description String?  @db.VarChar(500)
  ttl         Int      // Time window in milliseconds
  limit       Int      // Number of requests allowed in time window
  endpoints   String[] @default([]) // Specific endpoints this applies to (empty = all)
  is_active   Boolean  @default(true)
  priority    Int      @default(0) // Higher priority rules are evaluated first
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  created_by  String?  @db.Uuid
  updated_by  String?  @db.Uuid

  // Relations
  creator User? @relation("rate_limit_creator", fields: [created_by], references: [id], onDelete: SetNull)
  updater User? @relation("rate_limit_updater", fields: [updated_by], references: [id], onDelete: SetNull)

  @@map("rate_limit_configs")
  @@index([name])
  @@index([is_active])
  @@index([priority])
}